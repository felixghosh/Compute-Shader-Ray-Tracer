#version 430 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D imgOutput;

uniform vec3 light_position;

bool intersect(vec3 ray_d, vec3 ray_o, vec3 sphere_c, float sphere_r, inout float t) {
    vec3 orig2center = sphere_c - ray_o;
    float tca = dot(orig2center, ray_d); 
    float d2 = dot(orig2center, orig2center) - tca * tca;

    if(d2 > sphere_r) {
        return false;
    }

    float thc = sqrt(sphere_r - d2);
    float t0 = tca - thc;
    float t1 = tca + thc;

    if (t0 > t1) {
        float tmp = t1;
        t1 = t0;
        t0 = tmp;
    }

    if (t0 < 0) {
        t0 = t1;
        if( t0 < 0) {
            return false;
        }
    }

    t = t0;
    return true;
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    float max_x = 5.0;
    float max_y = 5.0;
    ivec2 dims = imageSize(imgOutput);
    float x = float(texelCoord.x * 2 - dims.x) / dims.x;
    float y = float(texelCoord.y * 2 - dims.y) / dims.y;
    vec3 pos = vec3(x, y, 0.0);

    // Our gemometry
    vec3 ray_o = vec3(x * max_x, y * max_y, 0.0);
    vec3 ray_d = vec3(0.0, 0.0, -1.0); // ortho

    vec3 sphere_c = vec3(0.0, 0.0, -10.0);
    float sphere_r = 1.0;

    // Colision testing
    float t = 0;
    bool colision = intersect(ray_d, ray_o, sphere_c, sphere_r, t);
    vec3 p_colision = ray_o + t * ray_d;

    // Phong shading
    vec3 L = normalize(light_position - pos);
    vec3 N = normalize(p_colision - sphere_c);
    vec3 diffuse = vec3(0.4, 0.4, 1.0) * max(0, dot(L, N));

    // hit one or both sides
    vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);
    if (colision) {
        pixel = vec4(diffuse, 1.0);
    }
    
    imageStore(imgOutput, texelCoord, pixel);
}