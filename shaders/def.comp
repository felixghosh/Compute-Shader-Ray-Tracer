#version 430 core

#define EPISLON (0.000001)
#define INF     (1.0 / 0.0)

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D imgOutput;

// Sphere object
struct sphere_t {
    vec4 pos;
    vec4 color;
};

// Triangle object
struct triangle_t {
    vec4 p0;
    vec4 p1;
    vec4 p2;
    vec4 color;
}; 

//Sphere buffer
layout (std430, binding=2) buffer sphere_data
{
    sphere_t spheres[];
};

//Triangle buffer
layout (std430, binding=3) buffer triangle_data
{
    triangle_t triangles[];
};

uniform vec3 light_position;
uniform int  n_spheres;
uniform int  n_triangles;
uniform vec3 camera_pos;
uniform float camera_angle;

const float near_plane_z = -10.0;
const float plane_width = 3.0;
const float plane_height = 3.0;

struct hit_data {
    vec3 color;
    vec3 position;
    vec3 normal;
};

bool sphere_intersect(vec3 ray_d, vec3 ray_o, vec3 sphere_c, float sphere_r, float tmin, float tmax, inout float t) {
    vec3 orig2center = sphere_c - ray_o;
    float tca = dot(orig2center, ray_d); 
    float d2 = length(orig2center - ray_d*tca);

    if(d2 > sphere_r) {
        return false;
    }

    float thc = sqrt(sphere_r - d2);
    float t0 = tca - thc;
    float t1 = tca + thc;

    if (t0 > t1) {
        float tmp = t1;
        t1 = t0;
        t0 = tmp;
    }

    if (t0 < 0) {
        t0 = t1;
        if( t0 < 0) {
            return false;
        }
    }

    t = t0;
    return t > tmin && t < tmax;
}

bool triangle_intersect(vec3 ray_d, vec3 ray_o, triangle_t triangle, float tmin, float tmax, inout float t, inout vec3 normal) {
    vec3 p0 = triangle.p0.xyz;
    vec3 p1 = triangle.p1.xyz;
    vec3 p2 = triangle.p2.xyz;

    vec3 e1 = p1 - p0;
    vec3 e2 = p2 - p0;
    
    normal = cross(e1, e2);
    float m = -dot(normal, p0);
    
    t = (dot(normal, ray_o) + m) / -dot(normal, ray_d);

    // Check if  t within bounds
    if (t < tmin || t > tmax) {
        return false;
    }

    // Compute barycentrics
    vec3 Q = ray_o + ray_d * t;
    vec3 r = Q - p0;
    float v = length(cross(e1, r)) / length(normal);
    float w = length(cross(e2, r)) / length(normal); 

    // Check if within triangle
    if (v < EPISLON || w < EPISLON || (v + w) > 1) {
        return false;
    }
    
    return true;    
}


mat4 rotationMatrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

bool scene_intersection(vec3 ray_d, vec3 ray_o, bool any_hit, float tmin, float tmax, out hit_data hit)
{
    float nearest = INF;
    float t = 0;

    // Interare over our scene, searching for our first hit
    for (int i = 0; i < n_spheres; i++) {
        vec3 center = spheres[i].pos.xyz;
        float radius = spheres[i].pos.w;

        // Colision testing
        if (sphere_intersect(ray_d, ray_o, center, radius, tmin, tmax, t) && t < nearest) { 
            hit.position = ray_o + t * ray_d;
            hit.normal = normalize(hit.position - center);
            hit.color = spheres[i].color.xyz;
            nearest = t;

            if(any_hit) {
                return true;
            }
        }
    }

    for (int i = 0; i < n_triangles; i++) {
        triangle_t triangle = triangles[i];
        vec3 normal;

        // Colision testing
        if(triangle_intersect(ray_d, ray_o, triangle, tmin, tmax, t, normal) && t < nearest) {
            hit.position = ray_o + t * ray_d;
            hit.normal = normal;
            hit.color = triangle.color.xyz;
            nearest = t;

            if(any_hit) {
                return true;
            }
        }
    }

    return nearest != INF;
}


vec3 trace_ray(vec3 ray_d, vec3 ray_o)
{
    hit_data hit;
    hit_data shadow_hit;

    if (!scene_intersection(ray_d, ray_o, false, EPISLON, INF, hit)) {
        return vec3(0,0,0); // evironment base color
    };

    vec3 direct_color = hit.color;
    vec3 L = normalize(light_position - hit.position);
    vec3 shadow_ray_d = L;
    vec3 shadow_ray_o = hit.position;

    if(scene_intersection(shadow_ray_d, shadow_ray_o, true, 0.01, sqrt(dot(L,L)), shadow_hit)) {
        direct_color = vec3(0,0,0); 
    } 

    // Phong shading
    vec3 diffuse = direct_color * max(0, dot(L, hit.normal));

    return diffuse;
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    float max_x = 5.0;
    float max_y = 5.0;
    ivec2 dims = imageSize(imgOutput);
    int x_clip = texelCoord.x * 2 - dims.x;
    int y_clip = texelCoord.y * 2 - dims.y;
    float x = float(x_clip) / dims.x;
    float y = float(y_clip) / dims.y;
    vec3 pos = vec3(x, y, 0.0);

    // Compute ray
    vec3 ray_o = camera_pos;
    vec3 plane_pos = vec3(camera_pos.x + x * plane_width, camera_pos.y + y * plane_height, camera_pos.z + near_plane_z);
    vec3 ray_d = plane_pos - ray_o;
    mat4 rot = rotationMatrix(vec3(0.0, 1.0, 0.0), camera_angle);
    ray_d = (rot * vec4(ray_d, 0.0)).xyz;
    ray_d = normalize(ray_d);

    // Ray-trace
    vec3 color = trace_ray(ray_d, ray_o);

    // Write result to texture
    vec4 pixel = vec4(color, 1.0);
    imageStore(imgOutput, texelCoord, pixel);
}