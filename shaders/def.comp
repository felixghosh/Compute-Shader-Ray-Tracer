#version 430 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D imgOutput;

// Sphere object
struct sphere_t {
    vec4 pos;
    vec4 color;
};

//Sphere buffer
layout (std430, binding=2) buffer scene_data
{
    sphere_t spheres[];
};

uniform vec3 light_position;
uniform int  n_spheres;
uniform vec3 camera_pos;

const float near_plane_z = -10.0;
const float plane_width = 3.0;
const float plane_height = 3.0;


bool intersect(vec3 ray_d, vec3 ray_o, vec3 sphere_c, float sphere_r, inout float t) {
    vec3 orig2center = sphere_c - ray_o;
    float tca = dot(orig2center, ray_d); 
    float d2 = dot(orig2center, orig2center) - tca * tca;

    if(d2 > sphere_r) {
        return false;
    }

    float thc = sqrt(sphere_r - d2);
    float t0 = tca - thc;
    float t1 = tca + thc;

    if (t0 > t1) {
        float tmp = t1;
        t1 = t0;
        t0 = tmp;
    }

    if (t0 < 0) {
        t0 = t1;
        if( t0 < 0) {
            return false;
        }
    }

    t = t0;
    return true;
}

mat4 rotationMatrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    float max_x = 5.0;
    float max_y = 5.0;
    ivec2 dims = imageSize(imgOutput);
    int x_clip = texelCoord.x * 2 - dims.x;
    int y_clip = texelCoord.y * 2 - dims.y;
    float x = float(x_clip) / dims.x;
    float y = float(y_clip) / dims.y;
    vec3 pos = vec3(x, y, 0.0);

    // Our gemometry
    vec3 ray_o = camera_pos;
    vec3 plane_pos = vec3(camera_pos.x + x * plane_width, camera_pos.y + y * plane_height, camera_pos.z + near_plane_z);
    vec3 ray_d = plane_pos - ray_o;
    ray_d = normalize(ray_d);

    // Miss color
    vec3 color = vec3(0, 0,0);

    // Interare over our scene, searching for our first hit
    for (int i = 0; i < n_spheres; i++) {
        vec3 center = spheres[i].pos.xyz;
        float radius = spheres[i].pos.w;

        // Colision testing
        float t = 0;

        if (intersect(ray_d, ray_o, center, radius, t)) { 
            vec3 p_colision = ray_o + t * ray_d;

             // Phong shading
            vec3 L = normalize(light_position - p_colision);
            vec3 N = normalize(p_colision - center);
            vec3 diffuse = spheres[i].color.xyz * max(0, dot(L, N));
            color = diffuse;
        }
    }

    // Write result to texture
    vec4 pixel = vec4(color, 1.0);
    imageStore(imgOutput, texelCoord, pixel);
}