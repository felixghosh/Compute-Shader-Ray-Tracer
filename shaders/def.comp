#version 430 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D imgOutput;

//Sphere buffer
layout (std430, binding=2) buffer scene_data
{
    vec4 sphere[];
};

uniform vec3 light_position;
uniform int  n_spheres;

bool intersect(vec3 ray_d, vec3 ray_o, vec3 sphere_c, float sphere_r, inout float t) {
    vec3 orig2center = sphere_c - ray_o;
    float tca = dot(orig2center, ray_d); 
    float d2 = dot(orig2center, orig2center) - tca * tca;

    if(d2 > sphere_r) {
        return false;
    }

    float thc = sqrt(sphere_r - d2);
    float t0 = tca - thc;
    float t1 = tca + thc;

    if (t0 > t1) {
        float tmp = t1;
        t1 = t0;
        t0 = tmp;
    }

    if (t0 < 0) {
        t0 = t1;
        if( t0 < 0) {
            return false;
        }
    }

    t = t0;
    return true;
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    float max_x = 5.0;
    float max_y = 5.0;
    ivec2 dims = imageSize(imgOutput);
    float x = float(texelCoord.x * 2 - dims.x) / dims.x;
    float y = float(texelCoord.y * 2 - dims.y) / dims.y;
    vec3 pos = vec3(x, y, 0.0);

    // Defining our ray
    vec3 ray_o = vec3(x * max_x, y * max_y, 0.0);
    vec3 ray_d = vec3(0.0, 0.0, -1.0); // ortho

    // Miss color
    vec3 color = vec3(0, 0,0);

    // Interare over our scene, searching for our first hit
    for (int i = 0; i < n_spheres; i++) {
        vec3 center = sphere[i].xyz;
        float radius = sphere[i].w;

        // Colision testing
        float t = 0;

        if (intersect(ray_d, ray_o, center, radius, t)) { 
            vec3 p_colision = ray_o + t * ray_d;

             // Phong shading
            vec3 L = normalize(light_position - pos);
            vec3 N = normalize(p_colision - center);
            vec3 diffuse = vec3(0.4, 0.4, 1.0) * max(0, dot(L, N));
            color = diffuse;
        }
    }

    // Write result to texture
    vec4 pixel = vec4(color, 1.0);
    imageStore(imgOutput, texelCoord, pixel);
}