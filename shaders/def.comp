#version 430 core

#define EPISLON 0.000001
#define INF     1.0 / 0.0;

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D imgOutput;

// Sphere object
struct sphere_t {
    vec4 pos;
    vec4 color;
};

// Triangle object
struct triangle_t {
    vec4 p0;
    vec4 p1;
    vec4 p2;
    vec4 color;
}; 

//Sphere buffer
layout (std430, binding=2) buffer sphere_data
{
    sphere_t spheres[];
};

//Triangle buffer
layout (std430, binding=3) buffer triangle_data
{
    triangle_t triangles[];
};

uniform vec3 light_position;
uniform int  n_spheres;
uniform int  n_triangles;
uniform vec3 camera_pos;
uniform float camera_angle;

const float near_plane_z = -10.0;
const float plane_width = 3.0;
const float plane_height = 3.0;


bool sphere_intersect(vec3 ray_d, vec3 ray_o, vec3 sphere_c, float sphere_r, inout float t) {
    vec3 orig2center = sphere_c - ray_o;
    float tca = dot(orig2center, ray_d); 
    float d2 = dot(orig2center, orig2center) - tca * tca;

    if(d2 > sphere_r) {
        return false;
    }

    float thc = sqrt(sphere_r - d2);
    float t0 = tca - thc;
    float t1 = tca + thc;

    if (t0 > t1) {
        float tmp = t1;
        t1 = t0;
        t0 = tmp;
    }

    if (t0 < 0) {
        t0 = t1;
        if( t0 < 0) {
            return false;
        }
    }

    t = t0;
    return true;
}

/* Möller–Trumbore triangle intersection */
bool triangle_intersect(vec3 ray_d, vec3 ray_o, triangle_t triangle, inout float t, inout vec3 normal) {
    vec3 p0 = triangle.p0.xyz;
    vec3 p1 = triangle.p1.xyz;
    vec3 p2 = triangle.p2.xyz;

    vec3 e1 = p1 - p0;
    vec3 e2 = p2 - p0;
    vec3 pvec = cross(ray_d, e2);
    float det = dot(e1, pvec);

    /* non-culling version */
    if(det > -EPISLON && det < EPISLON) 
        return false;

    float inv_det = 1 / det;
    vec3 tvec = ray_o - p0;
    float u = dot(tvec, pvec) * inv_det;
    
    if(u < 0 || u > 1.0)
        return false;

    vec3 qvec = cross(tvec, e1);
    float v = dot(ray_d, qvec) * inv_det;

    if (v < 0 || u + v > 1.0)
        return false;    

    t = dot(e2, qvec) * inv_det;
    normal = normalize(cross(e1, e2));
    return true;
}


mat4 rotationMatrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    float max_x = 5.0;
    float max_y = 5.0;
    ivec2 dims = imageSize(imgOutput);
    int x_clip = texelCoord.x * 2 - dims.x;
    int y_clip = texelCoord.y * 2 - dims.y;
    float x = float(x_clip) / dims.x;
    float y = float(y_clip) / dims.y;
    vec3 pos = vec3(x, y, 0.0);

    // Our gemometry
    vec3 ray_o = camera_pos;
    vec3 plane_pos = vec3(camera_pos.x + x * plane_width, camera_pos.y + y * plane_height, camera_pos.z + near_plane_z);
    vec3 ray_d = plane_pos - ray_o;
    mat4 rot = rotationMatrix(vec3(0.0, 1.0, 0.0), camera_angle);
    ray_d = (rot * vec4(ray_d, 0.0)).xyz;
    ray_d = normalize(ray_d);

    // Miss color
    vec3 color = vec3(0, 0,0);
    float nearest = INF;
    float t = 0;

    // Interare over our scene, searching for our first hit
    for (int i = 0; i < n_spheres; i++) {
        vec3 center = spheres[i].pos.xyz;
        float radius = spheres[i].pos.w;

        // Colision testing
        if (sphere_intersect(ray_d, ray_o, center, radius, t) && t < nearest) { 
            vec3 p_colision = ray_o + t * ray_d;

             // Phong shading
            vec3 L = normalize(light_position - p_colision);
            vec3 N = normalize(p_colision - center);
            vec3 diffuse = spheres[i].color.xyz * max(0, dot(L, N));
            color = diffuse;
            nearest = t;
        }
    }

    for (int i = 0; i < n_triangles; i++) {
        triangle_t triangle = triangles[i];
        vec3 normal;

        // Colision testing
        if(triangle_intersect(ray_d, ray_o, triangle, t, normal) && t < nearest) {
            vec3 p_colision = ray_o + t * ray_d;

             // Phong shading
            vec3 L = normalize(light_position - p_colision);
            vec3 diffuse = triangle.color.xyz * max(0, dot(L, normal));
            color = diffuse;
            nearest = t;
        }
    }

    // Write result to texture
    vec4 pixel = vec4(color, 1.0);
    imageStore(imgOutput, texelCoord, pixel);
}